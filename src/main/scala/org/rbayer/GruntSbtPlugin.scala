//------------------------------------------------------------------------------
// Copyright (c) 2014 Ross Bayer
//------------------------------------------------------------------------------

package org.rbayer

import sbt._
import Keys._

/**
 * sbt plugin that provides integration with
 * <a href="http://gruntjs.com/">Grunt.js</a> that allows execution of Grunt.js
 * builds from within sbt.
 *
 * In addition to a basic <code>grunt</code> command that allows arbitrary
 * execution of grunt commands from the sbt console, this plugin also provides
 * tasks for executing one or more grunt tasks as part of a the compile
 * and test phases (with the ability to extend other configurations as well).
 *
 * @author Ross Bayer
 */
object GruntSbtPlugin extends Plugin {

  /**
   * Settings and tasks for the grunt-sbt plugin
   */
  object GruntKeys {

    val gruntPath = settingKey[String]("The path to the grunt executable. By " +
      "default, the plugin will look for `grunt` in the $PATH.")

    val gruntNodePath = settingKey[String]("The path to the node.js " +
      "executable.  By default, the plugin will look for `node` in the $PATH.")

    val gruntNpmPath = settingKey[String]("The path to the npm executable. " +
      "By default, the plugin will look for `npm` in the $PATH.")

    val gruntTasks = settingKey[Seq[String]]("Sequence of grunt tasks to " +
      "execute as part of the `grunt` task for a particular configuration.  " +
      "For instance, for `Compile`, this could be `jshint` and `build`")

    val gruntResourcesDirectory = settingKey[Option[File]]("Directory " +
      "where files generated by the grunt process are located.  This " +
      "directory, if set, will be added to the managed resources of the " +
      "project.")

    val gruntResourcesClasspath = settingKey[File]("Classpath to use " +
      "in final jar for accessing resource files generated by grunt and " +
      "output to the `gruntOutputDirectory`.  This path will be relative to " +
      "the root of the JAR (i.e. `META-INF/resources/...`)")

    val gruntForce = settingKey[Boolean]("If true, the `--force` option " +
      "will be used when executing grunt, thus ignoring failures.")

    lazy val grunt = taskKey[Seq[File]]("Executes grunt tasks defined by the " +
      "`gruntTasks` key.")

    lazy val npmInstall = taskKey[Int]("Executes `npm install ` in the " +
      "project's parent directory if a package.json file is present.")
  }

  import GruntKeys._

  /**
   * Base sequence of settings for sbt for an arbitrary configuration.
   */
  val basePerConfigGruntSettings: Seq[Setting[_]] = Seq(
    gruntTasks := Seq(""),
    gruntForce := false,
    grunt <<= gruntTask,
    gruntResourcesDirectory := None,
    gruntResourcesClasspath := file("META-INF/resources")
  )

  /**
   * Core settings used by all configurations.
   */
  val baseGruntSettings: Seq[Setting[_]] = Seq(
    gruntPath := "grunt",
    gruntNpmPath := "npm",
    gruntNodePath := ""
  )

  /**
   * Sequence of settings to be included in a user's build.sbt file to
   * add grunt support to their build.  This includes defining grunt tasks
   * in the <code>Compile</code> and <code>Test</code> configurations.
   */
  val gruntSettings: Seq[Setting[_]] =
    baseGruntSettings ++
    gruntSettingsIn(Compile, Seq(
      gruntTasks := Seq("build"),
      npmInstall <<= npmInstallTask,
      resourceGenerators in Compile <+= gruntTask,
      (resources in Compile) <<= (resources in Compile) dependsOn (npmInstall in Compile)
    )) ++
    gruntSettingsIn(Test, Seq(
      gruntTasks := Seq("test"),
      (grunt in Test) <<= (grunt in Test) dependsOn (executeTests in Test),
      (test in Test) <<= (test in Test) dependsOn (grunt in Test)
    ))

  override lazy val settings = Seq(
    commands ++= Seq(
      gruntCmd
    )
  )

  /**
   * Implementation of grunt task that will execute one or more tasks defined
   * by the <code>gruntTasks</code> setting via the <code>grunt</code> command.
   */
  lazy val gruntTask: Def.Initialize[Task[Seq[File]]] = Def.task {
    val force = if (gruntForce.value) "--force" else ""
    val log = streams.value.log

    exec(
      gruntNodePath.value,
      gruntPath.value,
      args = Seq(force) ++ gruntTasks.value,
      cwd = thisProject.value.base,
      s = Some(streams.value))

    val gruntOutputDir: Option[File] = gruntResourcesDirectory.value
    gruntOutputDir map processManagedFiles(
      resourceManaged.value,
      gruntResourcesClasspath.value,
      log) getOrElse Seq.empty
  }

  /**
   * Task that will execute <code>npm install</code> in the current working
   * directory.
   */
  lazy val npmInstallTask: Def.Initialize[Task[Int]] = Def.task {
    // Don't execute if no package.json is found in directory
    val cwd = thisProject.value.base
    val pkgFileExists = (cwd / "package.json").exists

    if (pkgFileExists) exec(
      gruntNodePath.value,
      gruntNpmPath.value,
      args = Seq("install"),
      cwd = cwd,
      s = Some(streams.value))
    else 0
  }

  /**
   * Command for executing the <code>grunt</code> command interactively from
   * the sbt console.
   */
  lazy val gruntCmd = Command.single("grunt") { (state, task) =>
    val extracted = Project.extract(state)
    val nodePath = extracted.getOpt(gruntNodePath).get
    val cmd = extracted.getOpt(gruntPath).get

    exec(nodePath, cmd, Seq(task))

    state
  }

  /**
   * Convenience method for including grunt-sbt plugin configuration values
   * with an arbitrary sbt configuration.
   *
   * This method will add the default settings to the configuration, and then
   * allow the user to update the values as they wish.
   *
   * @param c The configuration to add grunt values to.
   * @param overrides Sequence of settings that can be used to override or
   *                  extend the default values provided by the plugin.
   *
   * @return The final sequence of settings in the specified configuration.
   */
  def gruntSettingsIn(c: Configuration, overrides: Seq[Setting[_]] = Seq.empty[Setting[_]]): Seq[Setting[_]] =
    inConfig(c)(basePerConfigGruntSettings ++ overrides)

  /**
   * Executes a node command in an external process.
   *
   * @param nodePath Path to the <code>node</code> executable.
   * @param cmd The command to execute.  This can be either a fully-qualified
   *            filesystem path to the command, or a basename (assumed to be
   *            on the user's $PATH).
   * @param args Sequence of arguments to pass to the command.
   * @param s Optional TaskStreams object used for debug logging.
   *
   * @return The return code from the node process.
   */
  private def exec(
    nodePath: String,
    cmd: String,
    args: Seq[String] = Seq(),
    cwd: File = file("."),
    s: Option[TaskStreams] = None):Int = {

    val fullCmd = (Seq[String](nodePath, cmd) ++ args) filter { _.length > 0 } mkString " "

    s map { _stream =>
      _stream.log.info(s"Executing grunt-sbt command: $fullCmd")
      _stream.log.debug(s"Grunt cwd: $cwd")
    }

    val rc = Process(fullCmd, cwd).!

    if (rc == 0) rc else sys.error(s"Grunt generated non-zero return code: $rc")
  }

  /**
   * Process resource files generated by grunt, copy them to the resourceManaged
   * directory if necessary, and return the sequence of files to be added to
   * the final artifact.
   *
   * @param log Logger to log debug messages to.
   * @param resourceManaged Directory where managed resources are stored.
   * @param classpathTarget Path to copy files to in final Jar classpath.
   * @param outputDir The output directory where grunt generated files.
   *
   * @return Sequence of new files to be managed by the build.
   */
  private def processManagedFiles(
    resourceManaged: File,
    classpathTarget: File,
    log: Logger)
    (outputDir: File): Seq[File] = {

    // Find all generated files based on configured output directory
    val generatedFilesFinder = outputDir * "*" ** "*"
    val generatedFiles: Seq[File] = generatedFilesFinder.get

    generatedFiles foreach { f => log.debug(s"Found grunt-generated file: $f") }

    // If files are not children of the resourcesManaged directory, copy them
    // there.
    val resourceManagedRoot: File = resourceManaged / classpathTarget.getPath
    val filesToCopy: Seq[File] = ((generatedFilesFinder --- (resourceManagedRoot / "*")) filter (_.isFile)).get
    val managedFiles: Seq[File] = filesToCopy map { f =>
      val relPath = IO.relativize(outputDir, f) getOrElse sys.error("Cannot calculate relative path of file")
      resourceManagedRoot / relPath
    }

    IO.copy(filesToCopy zip managedFiles, overwrite = true)

    managedFiles foreach { f => log.debug(s"Copied managed file: $f") }
    managedFiles
  }
}
